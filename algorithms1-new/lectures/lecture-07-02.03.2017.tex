\documentclass[../main.tex]{subfiles}

%Sample lecture


\begin{document}
	\section{Лекция 7. Очередь. Приоритетная очередь}
	
	\subsection{Очередь}
	
	Одной из полезных структур данных является \textit{очередь}. Эта структура описывает очередь в самом естественном смысле: первый, кто пришел в очередь, первым и уйдет.
	
	Наша структура поддерживает следующие операции:
	
	\begin{center}
		\begin{tabular}{c|c|c}
			Название & Описание & Сложность \\ \hline
			enque(el) & Добавить в очередь элемент & $ O(1) $ \\ \hline
			deque() & Взять первый элемент и удалить из очереди & $ O(1) $ \\ \hline
			is\_empty() & Вернуть истину, если очередь пуста & $ O(1) $	
		\end{tabular}
	\end{center}
	
	Эту структуру можно описать на основе списка. Будем хранить указатели на первый и последний элемент. При удалении возвращаем значение по первому указателю и передвигаем его. При добавлении связываем элемент с последним и передвигаем указатель. Оставим реализацию на упражнение читателю.
	
	Другая реализация основана на массиве. Но при реализации возникает много трудностей. Идея такая: пусть наш массив -- закольцованный буфер. Тогда будем поддерживать указатели на первый и на последний элемент. Попробуем описать структуру.
	
	\begin{struct}{queue\_on\_array}
		\State $Q$ -- array 
		\State $head$, $tail$ -- integer
		
		\State
		
		\Function{enque}{$el$}
			\If{$head == tail + 1$}
				\State \Return \textbf{error}
			\EndIf
			\State $Q[tail] := el$
			\State $tail := tail + 1 \ (\text{mod} \ n)$
		\EndFunction
	
		\State
		
		\Function{deque}{ }
			\State $x := Q[head]$
			\State $head := head + 1 \ (\text{mod} \ n)$ 
			\State \Return $x$
		\EndFunction
	\end{struct}
	
	Нужно еще вводить проверку на наличие элементов, проверку на переполнение, проверку еще на много чего, чтобы сохранить структуру в согласованном состоянии.
	
	\subsection{Очередь над стеком}
	
	Допустим, теперь мы хотим знать, какой элемент минимальный. Мы уже умеем хранить минимум на стеке, поэтому попробуем описать очередь над стеком. Идея заключается в следующем: заведем два стека. В первый будем добавлять элементы тогда, когда будем делать операцию enque. При операции deque будем переливать элементы из первого стека во второй и брать верхний во втором стеке. При этом на каждый стек заведем дополнительный, который будет поддерживать минимум. Приведем реализацию:
	
	\begin{struct}{queue\_on\_stack}
		\State $A, B$ -- stack\_min
		
		\State
		
		\Function{enque}{$el$}
			\State $A.push(el)$
		\EndFunction
		
		\State 
		
		\Function{deque}{ }
			\If{$B.is\_empty()$}
				\State $transfer(A, B)$
			\EndIf
			\State \Return $B.pop()$
		\EndFunction
		
		\State
		
		\Function{transfer}{$A, B$}
			\While{\textbf{not} $A.is\_empty()$}
				\State $B.push(A.pop())$
			\EndWhile
		\EndFunction
		
		\State
		
		\Function{min}{ }
			\State \Return $min(A.min(), B.min())$
		\EndFunction
	\end{struct}
	
	\subsection{Приоритетная очередь}
	
	Допустим теперь мы хотим удалять из очереди не первый элемент, а тот элемент, который будет иметь наименьший (или наибольший) \textit{приоритет}. Приоритет - это просто числовая характеристика элемента. Тогда от структуры мы хотим следующие операции:
	
	\begin{center}
		\begin{tabular}{c|c|c}
			Название & Описание & Сложность \\ \hline
			insert(el, pr) & Добавить в очередь элемент el с приоритетом pr& ??? \\ \hline
			extract\_min() & Взять первый элемент и удалить из очереди &  ??? \\ \hline
			is\_empty() & Вернуть истину, если очередь пуста & $ O(1) $	
		\end{tabular}
	\end{center}
	
	Сложность операций сильно зависит от реализации. Тривиальный подход хранения очереди в кольцевом буфере займет линейное время на взятие элемента и константу на добавление. Можно уменьшить сложность, но нельзя реализовать обе операции за константу.
	
	\begin{theorem}
		Нельзя реализовать операции вставки и взятия минимального элемента в приоритетной очереди за константное время.
	\end{theorem}
	\begin{proof}
		Пусть операции константы. Но тогда мы можем реализовать сортировку за линейное время: добавим элементы в виде чисел, и добавим их в приоритетную очередь. Потом будем делать взятие элементов, пока очередь не пуста. Получили $O(n)$, но ведь сортировка имеет сложность минимум $O(n \log n)$, получили противоречие.
	\end{proof}
	
	\subsection{Куча}
	
	\textit{Куча}, или \textit{двоичная куча}, или \textit{бинарное дерево} -- структура данных над деревом, поддерживающая минимальный элемент в корне, логарифмическую вставку и удаление. Она основана на поддержании следующего инварианта: $\forall x \in heap: x.val \geqslant x.par.val$, где $x.par$ - родитель узла. Особенностью этого дерева является то, что из каждого родителя выходит не более двух потомков.
	
	Приведем пример такого дерева:
	
	\begin{center}
		\begin{tikzpicture}
		\begin{scope}
		\node (top) at (10, 10) {$2$};
		
		\node (2-1) at (6, 	8) 	{$4$};
		\node (2-2) at (14, 8) 	{$5$};
		
		\node (3-1) at (4, 	6) 	{$20$};
		\node (3-2) at (8,  6) 	{$5$};
		\node (3-3) at (12, 6) 	{$6$};
		\node (3-4) at (16, 6) 	{$7$};
		
		\node (4-1) at (3,  4) 	{$21$};
		\node (4-2) at (5,  4) 	{$25$};
		\node (4-3) at (7,  4) 	{$6$};
		\node (4-4) at (9,  4) 	{$7$};
		\node (4-5) at (11, 4) 	{$4$};
		\node (4-6) at (13, 4) 	{$10$};
		
		\end{scope}
		
		\begin{scope}[>={Stealth[black]}, every edge/.style={draw=black}]
		
		\path [->] (top) edge (2-1);
		\path [->] (top) edge (2-2);
		
		\path [->] (2-1) edge (3-1);
		\path [->] (2-1) edge (3-2);
		
		\path [->] (2-2) edge (3-3);
		\path [->] (2-2) edge (3-4);
		
		\path [->] (3-1) edge (4-1);
		\path [->] (3-1) edge (4-2);
		
		\path [->] (3-2) edge (4-3);
		\path [->] (3-2) edge (4-4);
		
		\path [->] (3-3) edge (4-5);
		\path [->] (3-3) edge (4-6);
		
		\end{scope}
		\end{tikzpicture}
	\end{center}

	Дерево можно описывать в виде списка свзяности, введя структуру $node$ и поддерживая в каждом узле соответствующие ссылки:
	
	\begin{struct}{node}
		\State $value$ -- type
		\State $parent$ -- node
		\State $left\_child$ -- node
		\State $right\_child$ -- node
	\end{struct}
	
	У корня поле $parent$ будет иметь значение $null$, у листьев это значение будут иметь поля $left\_child$ и  $right\_child$.
	
	Для простоты мы будем описывать дерево в массиве. Первым элементом будет корень дерева, затем построчно все уровни дерева. Массивом из примера выше будет
	\[
	[2, \ 4, \ 5, \ 20, \ 5, \ 6, \ 7, \ 21, \ 25, \ 6, \ 7, \ 4, \ 10]
	\]
	
	При вставке будем записывать элемент в конец массива. При этом может нарушиться инвариант, поэтому придется восстановить справедливость. Эта процедура будет смотреть на родителя нового узла и, при необходимости, менять местами узлы. При удалении будем менять первый и последний элемент массива, удалять последний и восстанавливать справедливость уже с корнем. Эти функции называются $heaptify\_up$ и $heaptify\_down$.

	\begin{struct}{heap\_on\_array}
		\State $A$ -- array
		
		\Function{parent}{$i$}
			\State \Return $\lfloor\frac{i}{2}\rfloor$ 
		\EndFunction
		
		\State
		
		\Function{left\_child}{$i$}
			\State \Return $2i$
		\EndFunction
		
		\State
		
		\Function{right\_child}{$i$}
			\State \Return $2i + 1$
		\EndFunction
		
		\State 
		
		\Function{heaptify\_up}{$i$}
			\If{i > 1}
				\State $j := parent(i)$
				\If{A[i] < H[j]}
					\State swap($A[i], A[j]$)
					\State $heaptify\_up(j)$
				\EndIf
			\EndIf
		\EndFunction
		
		\State
		
		\Function{heaptify\_down}{$i$}
			\If{$left\_child(i) < n$ \textbf{or} $right\_child(i) < n$}
				\State $j := argmin(H[2i], H[2i +1])$
				\If{$H[i] > H[j]$}
					\State $swap(H[i], H[j])$
					\State $heaptify\_down(j)$				
				\EndIf
			\EndIf
		\EndFunction
	\end{struct}
	
	Утверждается, что после применения функций heaptify\_down и heaptify\_up свойство кучи будет восстановлено.
	
	\begin{statement}
		Свойство кучи может быть нарушено только на одном из ребер.
	\end{statement}

	
	\subsection{Сортировка кучей}
	С помощью такой структуры данных мы можем относительно быстро отсортировать массив и поддерживать его в таком состоянии: сначала добавим все элементы в кучу, а затем возьмем все, начиная с минимального.
	
	\pagebreak
\end{document} 