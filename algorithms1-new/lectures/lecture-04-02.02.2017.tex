\documentclass[../book.tex]{subfiles}


\begin{document}
	\section{Лекция 4. Алгоритмы стратегии <<разделяй и властвуй>>}
		\textit{Это черновик лекции, окончательный релиз будет как только вычитаю у лектора.}
		
		
		Стратегия <<разделяй и властвуй>> используется в еще некоторых полезных алгоритмах. Относительно простым является алгоритм быстрого возведения в степень.
		
		\subsection{Возведение в степень}
		
		Для начала приведем тривиальный алгоритм.
		
		%\TODO{Число цифр в записи}
		\begin{algorithm}[H]
			\caption{Возведение в степень}
			\begin{algorithmic}[1]
				\Require Числа $x, y \in Z$.
				\Ensure Число $x^y$.
				\Function{power}{$x, y$}
					\State $z := 1$
					\For{$i := 1$\textbf{ to }$y$}
						\State $z := z * x$
					\EndFor
					\State \Return $z$
				\EndFunction
			\end{algorithmic}
		\end{algorithm}
		
		\begin{time}
			Так как ответ на задачу имеет экспоненциальный размер, то и сложность будет по крайней мере экспоненциальная. Если смотреть точнее, то получится $T(n) = O(n^210^n)$, где $n$ - число цифр в записи числа.ответ
		\end{time}
		
		Алгоритм невероятно медленен, так как он выполнит честно каждое умножение, но есть способ вычислить степень быстрее. Для этого мы воспользуемся свойством степеней, а именно:
		
		\[
		x^n =
		\begin{cases}
			x^{2^\frac{n}{2}},& n = 2k \\
			x \cdot x^{n - 1},& n = 2k + 1
		\end{cases}
		\]
		
		Отсюда мы получаем рекуррентное соотношение для построения алгоритма, причем сделаем маленькую оптимизацию -- будем вычислять ответ по какому-то модулю $p$. На практике арифметика работы с целыми числами в компьютере сама по себе модульная: при переполнении типа данных мы начнем с нуля. Псевдокод будет выглядеть так:
		
		%\TODO{поменять рекуррентное соотношение}
		\begin{algorithm}[H]
			\caption{Бинарное возведение в степень}
			\begin{algorithmic}[1]
				\Require Числа $x, y, p\in Z$.
				\Ensure Число $x^y \mod \ p$.
				\Function{power2}{$x, y, p$}
					\If{$y == 0$}
						\State \Return 1
					\Else
						\State $t := \text{power2(x, y/2, p)}$
						\If{$y \ \text{mod} \ 2 == 0$}
							\State \Return $t^2 \ \text{mod} \ p$
						\Else
							\State \Return $t^2 \cdot x \ \text{mod} \ p$
						\EndIf
					\EndIf
				\EndFunction
			\end{algorithmic}
		\end{algorithm}
		
		\begin{time}
			При использовании этой оптимизации мы используем $O(n)$ возведений в квадрат чисел длины n.
		\end{time}
		
		\subsection{Вычисление медианы}
		
		Вернемся к самому нашему первому алгоритму. Вычисление медианы является частным случаем другой задачи - выбора $k$-ой порядковой статистики, поэтому логичнее решить более общую задачу.
		
		\begin{algorithm}[H]
			\caption{Рандомизированный алгоритм выбора к-ой порядковой статистики}
			\begin{algorithmic}[1]
				\Require Массив $A$, порядок $k$.
				\Ensure .
				\Function{select}{$A, k$}
					\State choose p
					\State i = Partition(A, p)
					\If{i == k}
						\State \Return b[i]
					\ElsIf{i < k}
						\State \Return Select(A[i:], k - i)
					\Else
						\State \Return Select(A[:i], k)
					\EndIf
				\EndFunction
			\end{algorithmic}
		\end{algorithm}
		
		Словами: выбираем случайный элемент $p$, запускаем Partition. Если попали в цель, то все хорошо, иначе же отправляем алгоритм в ту часть, где элемент заведомо будет.
		
		Все хорошо, но такой алгоритм дает в худшем случае асимптотику $O(n^2)$ из-за случайности выбора $p$. Посчитаем сколько времени потребуется алгоритму при таком случайном выборе.
		
		\begin{definition}
			Назовем текущий рекурсивный шаг алгоритма $j$-фазой, если для некоторого $j$ обрабатываемая часть массива $n'$ имеет размер
			\[
			\left(\frac{3}{4}\right)^{j + 1} \cdot n < n' \leqslant \left(\frac{3}{4}\right)^{j} \cdot n
			\]
		\end{definition}
		
		Для подсчета сложности будем использовать факт, что в данном алгоритме время, проведенное в одной $j$ фазе в среднем равно двум. Это понятно на уровне интуиции, ибо если нам не повезло с первого раза попасть в нужную половину, со второго раза мы попадем с большей вероятностью.
		
		Отсюда получаем время работы:
		\[\mathbb{E}(T(n)) 
		\leqslant
		\mathbb{E}
		\left(
		\sum_{j = 0}^{\log_\frac{4}{3}n} 2c
		\left(
		{\frac{3}{4}}
		\right)^j n
		\right) =
		8cn
		\]
		
		Получили линейное время в среднем случае. Для улучшения асимптотики алгоритм можно переписать, сделав выбор опорного элемента детерминированным.
		
		%\TODO{индексы}
		\begin{algorithm}[H]
			\caption{Детерменированный алгоритм выбора к-ой порядковой статистики}
			\begin{algorithmic}[1]
				\Require Массив $A$, число $1 \leqslant k \leqslant A.size$.
				\Ensure $k$ порядковая статистика.
				\Function{dselect}{$A, k$}
					\State $a_1$ = A[0:5], $a_2$ = A[5:10], \ldots
					\State sort($a_1$, \ldots, $a_n$)
					\State $m_1$ = $a_1[2]$, \ldots,
					\State p = dselect(($m_1$, \ldots,), n/10)
					\State i = Partition(A, p)
					\If{i == k}
						\State \Return b[i]
					\ElsIf{i < k}
						\State \Return Select(A[i:], k - i)
					\Else
						\State \Return Select(A[:i], k)
					\EndIf
				\EndFunction
			\end{algorithmic}	
		\end{algorithm}
		
		Суть этого алгоритма в том, что опорный элемент выбирается более-менее близко к медианному элементу, а значит и сложность будет более или менее близкой к линейной. На практике же на этот выбор тратится уйма времени, так что быстрее работает рандомизированный алгоритм.
		
		\begin{comment}
		
		пусть $y$ содержит 10 десятичных цифр
		
		$x^y < \le (10^n)^(10^n)$
		тогда числ цифр оценивается как $n\cdot10^n$, то есть полиномиального алгоритма
		не существует
		алгоритм экспоненциальный
		
		
		% ...
		
		вычислить $x^{2^k}$ для всех $2^k$:
		$x^{999} = x\cdot x^{2}\cdot x^{4}\cdot x^{32}\cdot x^{64}\cdot\ldos\cdot x^{512}$
		

		%кусок лекции безнадёжно утерян
		
		$T(n) \leq T(\frac{n}{5}) + T(\frac{7n}{10} + cn$
		Покажем, что $T(n) \leq \frac{dn}{5} + \frac{7dn}{10}+cn \leq dn$ при $с
		\geq 10n$
		
		\end{comment}
	\pagebreak
\end{document}