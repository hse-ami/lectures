\documentclass[../main.tex]{subfiles}


\begin{document}
	\section{Лекция 6. Продолжение амортизационного анализа. Динамический массив. Стек.}
	
	\epigraph{<<Функция <<фи>> будет оценивать все то плохое, что у нас есть>>}{С. А. Объедков}
	
	CAUTION! MATHS IS HERE!
	
	\subsection{Динамический массив}
	Рассмотрим нам уже знакомую из курса программирования структуру данных: \textit{динамический массив}. Суть его в том, что его размер ограничен только доступной нам памятью. Эта структура поддерживает следующие операции:
	
	\begin{center}
		\begin{tabular}{c|c|c}
			Название & Описание & Сложность \\ \hline
			insert(el) & Вставляет в конец массива элемент & $ O(n) $ в худшем случае \\ \hline
			get(i) & Получает элемент по индексу & O(1) \\ \hline
			remove\_back() & Удаляет элемент из конца массива & O(1) \\  % проверить	
		\end{tabular}
	\end{center}
	
	Алгоритм вставки тривиален: если нам не хватило уже выделенной памяти, чтобы вставить элемент, мы просто выделяем новую память, размер которой будет в два раза больше, чем есть сейчас, копируем уже записанные элементы и приписываем в конец новый элемент. Именно поэтому сложность добавления $O(n)$ в худшем случае.
	
	Оценим время, требуемое на $n$ операций вставок в худшем случае. Для примера распишем таблицу нескольких первых вызовов insert'а. 
	
	\begin{center}
		\begin{tabular}{c|c|c|c}
			Шаг & Стоимость & Вместимость до & Вместимость после \\ \hline
			1 & 1 & 1 & 1 \\ \hline
			2 & 2 & 1 & 2 \\ \hline
			3 & 3 & 2 & 4 \\ \hline
			4 & 1 & 4 & 4 \\ \hline
			5 & 5 & 4 & 8 \\ 
		\end{tabular}
	\end{center}
	
	Пусть $\forall i: \hat c_i = 3$. Тогда %расписать, почему 3 монетки
	\[
	\sum_{i = 1}^{n} c_i \leqslant \sum_{i = 1}^{n} 3 = O(n)
	\]
	
	Значит время работы $n$ операций, а значит амортизированное время выполнения одной операции - константа. 
	
	\subsection{Потенциальный анализ}
	
	\subsubsection{Теория}
	
	\begin{definition}
		\textit{Потенциал} -- величина $\Phi$, зависимая от некоторого состояния $D_i$ структуры данных, на которую накладываются следующие условия:
		\[
			\begin{cases}
				\Phi(D_0) = 0 \\
				\Phi(D_i) \geqslant 0 & \forall i
			\end{cases}
		\]
	\end{definition}

	%можно отказаться от первого условия
	
	Неформально можно сказать, что при приближении структуры данных к <<плохому>> состоянию потенциал растет. Так, например, в динамическом массиве потенциал перед реаллокацией максимален.
	
	%мы хотим так определить
	
	Основная формула, связывающая амортизированную и фактическую стоимость операции:
	%определение
	\[
		\hat c_i = c_i + \Phi(D_i) - \Phi(D_{i-1})
	\]

	
	Отсюда при анализе $n$ операций получаем, что
	\[
	\sum_{i = 0}^{n} c_i
	=
	\sum_{i = 0}^{n} 
	\Big(
		\hat c_i + \Phi(D_{i-1}) - \Phi(D_i)
	\Big)
	=
	\sum_{i = 0}^{n}\big(\hat c_i\big) + \Phi(D_0) - \Phi(D_n)
	\leqslant \sum_{i = 0}^{n} \hat c_i
	\]
	
	Значит наш метод дает ту же амортизированную оценку, но другим способом.
	
	
	\subsubsection{Потенциальный анализ вектора}
	Проведем анализ для вектора. Пусть $\Phi(D_i) = 2 \cdot D.size_i + D.cap_i$, где $D.size_i$ -- размер массива на $i$ шаге, $D.cap_i$ -- вместимость массива том же шаге.
	
	Тогда возможны два случая: 
	\begin{enumerate}
		\item Вставка элемента происходит без реаллокации. Тогда
		\[
		\hat c_i 
		=
		c_i + \Phi(D_i) - \Phi(D_{i - 1})
		=
		1 + (2size_i - cap_i) - (2size_{i - 1} - cap_{i - 1})
		=
		3
		\]
		\item Вставка с реаллокацией. Тогда 
		\[
		\hat c_i
		=
		size_i + (2size_i - cap_i) - (2size_{i - 1} - cap_{i - 1}) % 
		=3
		\]
	\end{enumerate}
	
	Отсюда делаем вывод, что в среднем вставка в вектор занимает константное время.
	
	\subsubsection{Анализ операции delete.}
	
	Доопределим в нашей структуре данных операцию удаления последнего элемента. При этом возникает вопрос: в какой момент стоит уменьшать вместимость структуры? Ответ прост: тогда, когда занята четверть памяти, уменьшать вместимость в два раза. Тогда мы гарантируем, что при последующем добавлении не будет происходить частых реаллокаций.
	
	Введем характеристику $\alpha_i = \frac{size_i}{cap_i}$ и переопределим наш потенциал следующим образом:
	\[
	\Phi(D_i) = 
	\begin{cases}
		0, & i = 0 \\
		2size_i - cap_i, & i > 0, \alpha_i \geqslant \frac12 \\
		\frac{cap_i}{2} - size_i, & i > 0, \alpha_i < 0
	\end{cases}
	\]
	
	%\TODO{Затехать формулы}
	
	\textit{Тут будут формулы с лекции. Суть в том, что мы для каждого случая расписываем $\hat c_i$ и получаем везде константу.}
	
	\subsection{Стек}
	
	Рассмотрим еще одну структуру данных под названием \textit{стек}. Она поддерживает всего 4 операции:
	
	\begin{center}
		\begin{tabular}{c|c|c}
			Название & Описание & Сложность \\ \hline
			push(el) & Положить на стек элемент $el$ & $ O(1) $ \\ \hline
			pop() & Вернуть и удалить верхний элемент & $ O(1) $ \\ \hline
			top() & Вернуть верхний элемент & $ O(1) $ \\ \hline
			is\_empty() & Вернуть истину, если стек пуст & $ O(1) $	
		\end{tabular}
	\end{center}
	
	Реализуется стек очень просто: у нас есть массив, для него мы храним указатель на последний элемент. При добавлении мы передвигаем указатель на одну позицию вперед и пишем туда элемент.
	
	Иногда может возникнуть желание знать максимальный элемент на стеке. Так как наша структура не поддерживает поиск и произвольную адресацию, нам нужно завести отдельный стек только на хранение максимумов. 
	
	Тогда алгоритм будет следующим: при каждом добавлении элемента мы будем класть в другой стек текущий максимум. При удалении мы будем делать pop у этого дополнительного стека.
	
	
\end{document}