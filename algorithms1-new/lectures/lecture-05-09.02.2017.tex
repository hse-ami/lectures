\documentclass[../main.tex]{subfiles}


\begin{document}
	\section{Лекция 5. Введение в структуры данных}
	
	Когда мы рассматривали алгоритмы, мы говорили об обработке данных: как быстро найти результат, при этом мы не сильно говорили об эффективности по \textit{памяти}. В этой части курса мы будем говорить о том, как данные \textit{хранить} и как предоставлять к ним быстрый доступ.
	
	Сейчас мы рассмотрим примеры нескольких странных структур данных, которые нам помогут понять, как это работает
	
	\subsection{<<Быстрый>> массив}
	
	Пусть мы хотим описать структуру со следующими свойствами:
	\begin{center}
		\begin{tabular}{c|c|c}
			Название 		& Описание 											& Желаемое время\\ \hline
			init($n$)  		& Создает массив нулей на $n$ элементов	 			& O(1) 			\\ \hline
			read($i$)  		& Возвращает $i$-ый элемент массива					& O(1)			\\ \hline
			write($i, v$) 	& Записывает в $i$-ый элемент массива значение $v$  & O(1)
		\end{tabular}
	\end{center}
	
	Попробуем описать такую структуру:
	
	\begin{struct}{fast\_array}
		\State array A
		
		\Function{init}{n}:
		\State A := malloc(n)
		\For{i := 0 \textbf{to} n-1}
			\State A[i] = 0
		\EndFor
		\EndFunction
		
		\Function{read}{i}:
		\State \Return A[i]
		\EndFunction
		
		\Function{write}{i, v}:
		\State A[i] = v
		\EndFunction
	\end{struct}
	
	При таком раскладе наша инициализация работает за линейное время, поэтому придется отказаться от цикла в init.
	
	Другим подходом к инициализации может быть \textit{ленивая} инициализация: хранить информацию о том, была ли записана ячейка и пользоваться этим при чтении и записи. Заведем массив $B$ длины $n$, в котором на $i$ позиции будем хранить порядковый номер, под которым была инициализированна ячейка $i$. Заведем еще один массив $C$ длины $n$, в котором на $i$ позиции будем хранить номер ячейки, которая была проинициализирована $i$ по счету. Также заведем счетчик инициализированных ячеек. Наша структура примет следующий вид:

	\begin{struct}{fast\_array}
		\State array $A$
		\State array $B$
		\State array $C$
		\State integer $k$
		
		\Function{init}{n}:
			\State $A := $ malloc(n)
			\State $B := $ malloc(n)
			\State $C := $ malloc(n + 1)
			\State $k := 0$
		\EndFunction
		
		\Function{read}{i}:
			\If{is\_inited(i)}
				\State \Return $A[i]$
			\Else
				\State \Return $0$
			\EndIf
		\EndFunction
		
		\Function{write}{i, v}:
			\State A[i] = v
			\If{\textbf{not} is\_inited(i)}
				\State $k := k + 1$
				\State $B[i] = k$
				\State $C[k] = i$
			\EndIf
		\EndFunction
		
		\Function{is\_inited}{i}
			\State \Return $0 < B[i] \leqslant k$ \textbf{and} $C[B[i]] == i$
		\EndFunction
	\end{struct}
	
	%переформулировать
	Главную роль тут играет функция is\_inited. Ее задача - узнать, была ли проинициализирована ячейка. Ее корректность основана на том факте, что массив $C$ заполняется по порядку, а значит мы можем гарантировать, что если было проинициализировано $k$ ячеек, то в массиве $C$ ячейки c $1$ по $k$ тоже проинициализированы. % в любой момент алгоритма ячейки с 1 по k 
		
	\subsection{N вставок}
	
	Рассмотрим теперь структуру данных, поддерживающую логарифмический поиск.
	
	\begin{center}
		\begin{tabular}{c|c|c}
			Название 		& Описание 											& Желаемое время\\ \hline
			insert($e$) 	& Вставляет в структуру элемент $e$	 			& $O(\log n)$ 			\\
			search($e$)  	& Возвращает индекс $i$, если элемент есть в структуре,  & $O(\log^2n)$			\\
							&-1 иначе
		\end{tabular}
	\end{center} %амортизационный анализ. 
	
	Основная идея состоит в том, что поиск в отсортированном массиве занимает логарифмическое время. Значит нам необходимо постоянно поддерживать структуру в отсортированном состоянии. Тут мы жертвуем временем вставки, но при этом поиск будет быстрым. Также в нашей структуре данных будем поддерживать следующий инвариант: %написать во множественном числе
	$\forall i |A_i| \in \{0, 2^i\}$.
	
	\begin{struct}{fast\_search}
		\State arrays $A_0 \ldots A_{k - 1}$
		
		\Function{search}{$e$}
			\For{i := 0 \textbf{to} k - 1} %что такое к
				\State j := BinarySearch($a_i$, $e$)
				\State \Return j
			\EndFor 	
		\EndFunction
		
		\Function{Insert}{e}
			\State B := [e]
			\For{i := 0 \textbf{to} k - 1}
				\If{$|A_i|$ == 0}
					\State $A_i$ = B
					\State \textbf{break}
				\Else
					\State B:= merge($A_i, B$)
					\State $A_i$ = []
				\EndIf			
			\EndFor
		\EndFunction
	\end{struct}
	
	\begin{time}
		Формула времени для поиска в худшем случае, когда $\forall i |A_i| = 2^i$:
		\[
		T(n) = O\left( \sum_{i = 0}^{k - 1} \log_22^i \right) = O\left( \sum_{i = 0} ^ {k - 1} i \right) = O(\log^2n)
		\]
	\end{time}
	
	Для вставки в худшем случае, когда $\forall i |A_i| = 2^i$:
	\[
	T(n) = O\left( \sum_{i = 0}^{k - 1} 2^i \right) = O\left( \sum_{i = 0}^{\lceil \log (n + 1)\rceil} 2^i\right) = O(n)
	\]
	
	\subsection{Амортизационный анализ}
	
	\begin{definition}
		\textit{Амортизационный анализ} - метод подсчета времени работы нескольких запусков алгоритма При таком подходе время выполнения $n$ запусков берется как сумма времени выполнения запусков. %берем время выполнения n операций. переписать
	\end{definition}
	
	Основная идея состоит в том, что если $n$ операций затратили $O(n)$ времени, то амортизированная стоимость одного запуска - константа.
		
	
	Одной из реализаций этого метода является \textit{банковский метод}.
	
	\subsubsection{Банковский метод}
	%проверить связность
	
	Суть метода в состоит в том, что за выполнение каждой элементарной операции мы <<кладем>> в банк некоторое количество условных единиц (назовем ее \textit{монеткой}), которые оплачивают нашу операцию. 
	
	Введем обозначения:
	\begin{sign}
		$D_i$ - структура данных $D$ после применения $i$-ой операции.
	\end{sign}
	\begin{sign}
		$c_i$ - настоящая стоимость (время) выполнения $i$-ой операции
	\end{sign}
	\begin{sign}
		$\hat{c}$ - уплаченная стоимость $i$-ой операции. 
	\end{sign}
	
	Также введем \textit{банк}, который является некоторой абстракцией, для работы с нашими монетками. Мы умеем класть монетки на счет в банк и забирать из банка наши монетки. 
	
	Условимся, что на $D_0$ наш счет в банке пуст. Наш анализ будет базироваться на следующем инварианте: % мы должны гарантировать, что инвариант выполняется
	
	\[
	\forall n : \sum_{i = 0}^n \hat{c}_i - \sum_{i = 0}^{n} c_i \geqslant 0	
	\]
	Иными словами, наш баланс в банке неотрицателен.
	
	Наш инвариант гарантирует, что при выполнении какой-нибудь тяжелой операции нам хватит монеток для ее выполнения. То есть мы должны платить такое количество монет во время легких операций, чтобы тяжелая операция смогла выполниться за излишек монет.
	
	%\TODO{Переписать}
	
	Схема будет понятнее на следующем примере.
	
	
	\subsection{Двоичный счетчик}
	
	Будем реализовывать простой двоичный счетчик при помощи массива нулей и единиц.
	
	\begin{struct}{binary\_counter}
		\State array A
		\State n := len(A)
		
		\Function{increment}{}
			\For{$i:= 0$ \textbf{to} $n - 1$}
				\If{$c[i] == 0$}
					\State $c[i] = 1$
					\State \textbf{break}
				\Else
					\State $c[i] = 0$
				\EndIf
			\EndFor
		\EndFunction
	\end{struct}
	
	Посчитаем время на выполнение $n$ операций используя банковский метод. Будем платить 2 монетки за операцию установки разряда из нуля в единицу -- одна монета на установку и одна в запас, и не будем платить ничего за сброс  разряда в ноль. Инвариант амортизационного анализа гарантирует, что при каждой единице есть монетка, чтобы сбросить ее в ноль. Получаем, что 
	\[
	\forall i: \ \sum_{i = 1}^{n} \hat{c}_i \leqslant 2n \Rightarrow T(n) = O(n)
	\]
	
	% дописать с конспекта
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	\pagebreak
\end{document}