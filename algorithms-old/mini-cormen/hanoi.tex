\section{Рекурсивные алгоритмы: задача о Ханойской башне. Оценка времени работы 
рекурсивного алгоритма при помощи рекуррентного соотношения. Доказательство 
оптимальности рекурсивного алгоритма.}

\subsection{Ханойские башни}
Рассмотрим классическую задачу, предложенную Эдуардом Люка в 1883 году. Есть 
три стержня, при этом на первый стержень нанизано 8 дисков. Нужно перенести все 
диски на другой стержень, соблюдая два правила: диски можно двигать только по 
одному и нельзя класть
диск большего радиуса на диск меньшего радиуса. Возможно ли это?

Придуманная профессором Люка легенда гласит, что в Великом храме города Бенарес,
 под собором, отмечающим середину мира, находится бронзовый диск, на котором 
 укреплены 3 алмазных стержня, высотой в один локоть и толщиной с пчелу. 
 Давным-давно, в самом начале времён, монахи этого монастыря провинились перед 
 богом Брахмой. Разгневанный Брахма воздвиг три высоких стержня и на один из 
 них возложил 64 диска, сделанных из чистого золота. Причем так, что каждый 
 меньший диск лежит на большем.

Как только все 64 диска будут переложены со стержня, на который Брахма сложил 
их при создании мира, на другой стержень, башня вместе с храмом обратятся в пыль
 и под громовые раскаты погибнет мир.

Интуиция подсказывает, что это возможно. Но каков тогда алгоритм и сколько 
операций ему необходимо?

Чтобы переместить $n$ дисков с первого стержня на второй, можно сначала 
переместить $n - 1$ диск на третий стержень, перенести самый большой диск на 
второй стержень, а затем переместить $n - 1$ диск с третьего стержня на второй. 
Такое рекурсивное решение представлено в Алгоритме \ref{algo:hanoi}.

\begin{algorithm}[H]
  \caption{Рекурсивный алгоритм решения задачи о Ханойской башне}
  \label{algo:hanoi}
  \begin{algorithmic}[1]
    \Require Число дисков $n$, начальный $i$, конечный $j$ и вспомогательный 
    $k$-ый стержень.
    \Ensure Последовательность пар $(x, y)$, соответствующих перемещению диска 
    со стержня $x$ на стержень $y$, приводящая к перемещению $n$ верхних дисков 
    со стержня $i$ на стержень $j$.
    \Function{Hanoi3}{$n, i, j, k$}
      \If{$n > 0$}
        \State \textsc{Hanoi3}($n - 1, i, j, k$)
        \State $i \to k$
        \State \textsc{Hanoi3}($n - 1, k, j, i$)
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Покажем с помощью дерева операций, как алгоритм работает для трёх дисков:

\begin{center}
  \begin{forest}
    for tree={
      parent anchor=south,
      child anchor=north,
      if n children=0{
        font=\itshape,
        tier=terminal,
      }{},
    }
    [{H(3, 1, 2, 3)} [{H(2, 1, 3, 2)} [{H(1, 1, 2, 3)} [$1 \to 2$]]
    [$1 \to 3$]
    [{H(1, 2, 3, 1)} [$2 \to 3$]]]
    [$1 \to 2$] 
    [{H(2, 3, 2, 1)} [{H(1, 3, 1, 2)} [$3 \to 1$]]
    [$3 \to 2$]
    [{H(1, 1, 2, 3)} [$1 \to 2$]]]]
  \end{forest}
\end{center}

По сути, данный алгоритм обходит дерево в глубину, выполняя необходимые 
перестановки.

\subsection{Оптимальность рекурсивного алгоритма и время его работы.}

Докажем, что данный алгоритм является \textbf{оптимальным}, то есть нет 
алгоритма, который бы решал эту же задачу быстрее.

Пусть $T_n$~--- минимальное количество операций, за которое можно перенести 
$n$ дисков. Сразу же заметим, что для переноса 0 дисков действий вообще не 
нужно. Тогда $T_0 = 0$.

Показанный ранее алгоритм показывает, что 
$T_n \leqslant 2T_{n - 1} + 1\text{ для } n > 0.$

Возникает логичный вопрос: а можно ли быстрее? Увы, но нет. Рано или поздно 
придётся перенести самый широкий диск. Но для этого необходимо поставить 
$n - 1$ диск на один стержень. Тогда можно сделать вывод, что $T_n \geqslant 
2T_{n - 1} + 1\text{ для } n > 0.$

Отсюда получаем, что минимальное количество операций задаётся следующим 
\emph{рекуррентным соотношением}:

\[T_n = \begin{cases}
2T_{n - 1} + 1, & n > 0 \\
0, & n = 0
\end{cases}\]

Прекрасно. Мы знаем, что алгоритм \ref{algo:hanoi} наиболее оптимален и знаем 
рекуррентное соотношение, задающее количество операций. Но можно ли найти 
\emph{замкнутую} формулу~--- такую, что она сразу даст нужное значение? Да, 
можно.

\begin{theorem}
  $T_n = 2^{n} - 1$
\end{theorem}
\begin{proof}
  Докажем это по индукции. База верна, так как $T_0 = 0 = 2^{0} - 1$. Теперь 
  пусть предположение верно для $n - 1$, то есть $T_{n - 1} = 2^{n - 1} - 1$.
   Тогда \[T_{n} = 2T_{n - 1} + 1 = 2(2^{n - 1} - 1) + 1 = 2^n - 2 + 1 = 2^n - 1\qedhere\]
\end{proof}

Теперь немного изменим задачу.
\subsection{Четыре стержня}

Допустим, что у нас четыре стержня, два из которых --- вспомогательные. Обозначим
\[n_m = \sum_{i=1}^mi = \frac{m(m+1)}{2}.\]
Для простоты предположим, что изначально на первом стержне находится $n_m$ дисков.

Чтобы переместить $n_m$ дисков с первого стержня на второй, можно сначала 
переместить $n_{m-1}$ дисков на четвертый стержень, затем переместить оставшиеся
 $m$ самых больших дисков на второй стержень, используя Алгоритм \ref{algo:hanoi}
  и третий стержень в качестве вспомогательного, и наконец переместить $n_{m-1}$
   дисков с четвертого стержня на второй. Такое рекурсивное решение представлено
    в Алгоритме \ref{algo:hanoi4}.

\begin{algorithm}[H]
  \caption{Рекурсивный алгоритм решения задачи о Ханойской башне на 4-х стержнях}
  \label{algo:hanoi4}
  \begin{algorithmic}[1]
    \Require Число дисков $n_m = \frac{m(m + 1)}{2}$, начальный $i$, конечный $j$ и 
    вспомогательные $k$ и $l$ стержни.
    \Ensure Последовательность пар $(x, y)$, соответствующих перемещению диска 
    со стержня $x$ на стержень $y$, приводящая к перемещению $n$ верхних дисков
     со стержня $i$ на стержень $j$.
    \Function{Hanoi4}{$n_m, i, j, k, l$}
      \If{$n > 0$}
        \State \textsc{Hanoi4}($n-m, i, l, k, j$)
        \State \textsc{Hanoi3}($m, i, j, k$)
        \State \textsc{Hanoi4}($n-m, l, j, i, k$)
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Алгоритм \ref{algo:hanoi4} можно обобщить на случай произвольного числа дисков 
$n$, например, так: на верхнем уровне рекурсии выбрать $n_{m-1}$, ближайшее 
снизу к $n$, а вместо $m$ в вызове алгоритма \algname{Hanoi3} использовать 
$n - n_m$.

Обозначим за $g(n_m)$ число шагов, требующихся Алгоритму \ref{algo:hanoi4} для 
решения задачи с $n_m$ дисками. Получаем следующее рекуррентное соотношение:
\[g(n_m) = \begin{cases}
  0, & n_m = 0; \\
  2g(n_{m-1}) + 2^m - 1, & n > 0.
  \end{cases}\]

Докажем по индукции, что $g(n_m) = (m - 1)2^m + 1$ (эту оценку можно получить, 
проанализировав дерево рекурсии).
\begin{description}
  \item[Базис:] $g(n_0) = 0 = -1 + 1 = (0 - 1) \cdot 2^0 + 1$.
  \item[Шаг:] Предположим, что $g(n_{m-1}) = (m - 2)2^{m-1} + 1$. Тогда
  \begin{align*} % requires amsmath; align* for no eq. number
     g(n_m) = {}& 2g(n_{m-1}) + 2^m - 1 = \\
     = {}& 2((m - 2)2^{m-1} + 1) + 2^m - 1 = \\
     = {}& (m - 2)2^m + 2 + 2^m - 1 = \\
     = {}& (m - 1)2^m + 1.
  \end{align*}
\end{description}

Таким образом, число шагов асимптотически зависит от числа входных дисков $n$ 
как $\Theta\left(\sqrt{n}\,2^{\sqrt{2n\,}}\right)$.
\footnote{Смысл этого утверждения уточним на следующих лекциях.} Можно ли 
переместить диски быстрее --- открытый вопрос.
