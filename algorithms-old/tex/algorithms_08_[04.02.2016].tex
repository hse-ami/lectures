\input{header.tex}

\begin{document}

\section*{Лекция 8 от 4.02.2016}

\subsection{Быстрое возведение в степень}
Пусть \(x = \overline{x_1 \ldots x_n}\), \(y = \overline{y_1 \ldots y_n}\). Можно ли за полиномиальное время возвести число $x$ в степень $y$?

Тупо умножать $x$ на себя $y$ совершенно неоптимально --- несложно показать, что сложность алгоритма будет $O(2^n)$ (где $n$ --- число цифр в числе). При этом само число $x^y$ содержит \(10^{n}n\) цифр. Получается, что один только размер результата экспоненциален, то есть полиномиальной сложности не хватит даже на вывод результата.

А если по модулю (т.е. результатом будет \(x^y \pmod{p}\) для некоторого указанного \(p\))? Прямое умножение всё равно достаточно медленно. Можно ли быстрее? Оказывается, что да.

\begin{algorithm}
	\caption{Быстрое возведение в степень}
	\begin{algorithmic}[1]
		\Function{Power}{$x, y, p$}\Comment{алгоритм считает \(x^y \pmod{p}\)}
		\If{\(y = 0\)}
			\State return 1
		\EndIf
		\State \(t \mathrel{:=} \textsc{Power}\left(x, \lfloor\frac{y}{2}\rfloor, p \right)\)
		\If{\(y \equiv 0 \pmod{2}\)}
			\State return \(t^2\)
		\Else
			\State return \(xt^2\)
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Легко понять, что глубина рекурсии для данного алгоритма равна $O(\log y) = O(n)$.

Покажем, как он работает на примере \(x = 4, y = 33\): \[x^{33} = x(x^{16})^{2} = x((x^{8})^2)^2 = x(((x^4)^2)^2)^2 = x((((x^2)^2)^2)^2)^2 \].
Как видно, для возведения числа в 33-ю степень достаточно 7 умножений.

\subsection{Обратная задача}

Пусть нам известны числа $x,\ z,\ p$, каждое по $n$ цифр. Можно ли за полиномиальное время найти число $y$ такое, что $x^y = z \pmod{p}$.

Сказать сложно --- с одной стороны, такой алгоритм ещё не смогли придумать. С другой стороны, не могут доказать того, что его нет. Это всё, вообще говоря, висит на известной проблеме $\mathrm{P} \mathrel{\overset{?}{=}} \mathrm{NP}$ и подробнее мы об этом поговорим ближе к концу курса.

\subsection{Обработка текста}
Предположим, у нас есть $n$ слов, и эти слова мы хотим разместить на странице (порядок, разумеется, не меняя --- это же, в конце концов, текст). При этом, шрифт моноширинный, а ширина строки ограничена. Что мы хотим --- разместить текст так, чтобы он был выровнен по обоим краям. При этом хотелось бы, чтобы пробелы были примерно одинаковы по ширине.

Введём такую ??? (меру? хз): $\varepsilon(i, j) = L-\sum\limits_{t=i}^j|w_t|-(j-i)$ --- число дополнительных пробелов в строке с $i$-го по $j$-ое слово.

Также введём $c(i, j)$ --- стоимость размещения.

\[
    c(i, j) = \begin{cases}
        +\infty, \epsilent(i, j) < 0\\
        \left( \frac{\epsilent(i, j)}{j-i} \right)^3, \epsilent(i, j) \geqslant 0\\
    \end{cases}
\]

И как это решать? Можно попробовать жадным алгоритмом --- просто ``впихивать'' слова в строку, пока влезают. Он тут не работает, так как он вообще не учитывает стоимость.

Попробуем наш извечный ``разделяй и властвуй''. Базовый случай --- слова помещаются в одну строку, а если не помещаются --- переносим и повторяем. Но тут тоже не учитывается стоимость, так что вряд ли будет сильно лучше.

Вход: $w_1, \ldots, w_n; c(i, j)$.

Выход: $j_0, \ldots, j_{l+1}$, такие что $j_0 = 1,\ j_{l+1} = n,\ \sum c(j_i, j_{i+1})$ минимальна.

Сколько всего таких наборов? Мест, где в принципе может оказаться разрып строки --- $n-1$, в каждом можно поставить или не поставить --- итого $2^{n-1}$ разбиений.

Пусть $OPT(j)$ --- стоимость оптимального размещения слов с $j$-ого по $n$-ное. Наша задача --- вычислить $OPT(1)$. А как?

\[
    OPT(1) = \min\limits_{i\leqslant n}\{c(1, i)+OPT(i+1)\}
\]

\begin{lstlisting}
OPT(j):
    if j = n+1 then return 0
    f:= +inf
    for i:= j to n do
     f:= min(f, c(i, j)+OPT(i+1))
\end{lstlisting}

$(*)\ \mathrm{OPT}(3) =\begin{cases}
    0, & j>n\\
    \min\limits_{i = j\ldots n}\left\{ c(j, i) + \mathrm{OPT}(3)(i+1) \right\}, & \text{иначе}
\end{cases}$

А сложность? Построив дерево, заметим, что $\mathrm{OPT}(3)$ вычисляется два раза; $\mathrm{OPT}(4)$ -- три раза и так далее.

Будем сохранять результаты:

\begin{algorithmic}
	\Function{OPT\_cache}{$t$}
	\If{\(M[j] \neq \textrm{NULL}\)}
	\Else
		\State \(M[j] \mathrel{:=} \textsc{OPT}(j)\)
	\EndIf
	\State return \(M[j]\)
	\EndFunction
\end{algorithmic}

Такая методика называется \emph{динамическим программированием}.

Основная идея --- каждая задача зависит от полиномиального числа других задач.

\end{document}
