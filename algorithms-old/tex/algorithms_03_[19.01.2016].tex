\input{header.tex}

\begin{document}

\section*{Лекция 3 от 19.01.2016}

\subsection*{Нотация}

\[\Theta(g(n)) = \left\{ f(n)\mid \exists c_1>0, c_2>0 \exists n_0: \forall n \geqslant n_0 \implies 0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n) \right\},\]

$\Theta$ --- \emph{асимптотическое} $=$. Например, $2n = \Theta(n)$. По определению, $c_1n \leqslant 2n \leqslant c_2n$. Тогда $c_1 = 1, c_2 = 2$.

\[O(g(n)) = \left\{ f(n)\mid \exists  c_2>0 \exists n_0: \forall n \geqslant n_0 \implies 0\leqslant f(n) \leqslant c_2g(n) \right\}\]

$O$ --- \emph{асимптотическое} $\leqslant$. Например, по этому определению $n = O(n \log{n})$, так как при достаточно больших $n_0$ $\log n > 1$. Тогда $c_2 = 1$.

\[\Omega(g(n)) = \left\{ f(n)\mid \exists c_1>0 \exists n_0: \forall n \geqslant n_0 \implies 0\leqslant c_1g(n)\leqslant f(n) \right\}\]

$\Omega$ --- \emph{асимптотическое} $\geqslant$. Например, $n \log n = \Omega(n \log n)$ и $n \log n = \Omega(n)$. В обоих случаях подходит $c_1 = 1$.

\[o(g(n)) = \left\{ f(n)\mid \forall  c_2>0 \exists n_0: \forall n \geqslant n_0 \implies 0\leqslant f(n) \leqslant c_2g(n) \right\}\]

$o$ --- \emph{асимптотическое} $<$. Например, $n = o(n \log n)$. Покажем это. Пусть $n < c_2 n \log n \iff 1 < c_2 \log n \iff n > 2^{1/c_2}$. Тогда $n_0 = [2^{1/c_2} + 1]$

\[\omega(g(n)) = \left\{ f(n)\mid \forall c_1>0 \exists n_0: \forall n \geqslant n_0 \implies 0\leqslant c_1g(n)\leqslant f(n) \right\}\]

$\omega$ --- \emph{асимптотическое} $>$. Например, нельзя сказать, что $n \log n = \omega(n \log n)$. Но можно сказать, что  $n \log n = \omega(n)$. 

\

Когда мы пишем такую нотацию, мы подразумеваем функции, а не числа. Если же указывать функции явно, то это можно сделать с помощью $\lambda$-нотации:

\[\lambda n.n \in o(\lambda n.n \log_2 n)\]

\textbf{Примечание:} данная нотация очень похожа на лямбда-функции в Python:
\[\verb|lambda x: x * x| \iff \lambda x. x^2\] 

Заметим, что в логарифмах можно свободно менять основание: $\log_c n = \frac {\log_2 n}{\log_2 c}$. Именно поэтому не пишут основание логарифма.

\subsection*{Разделяй и властвуй. Быстрая сортировка}

Ход действий при алгоритме \textbf{"разделяй и властвуй"}:
\begin{enumerate}
	\item Разбить задачу на подзадачи.
	\item Каждую подзадачу решить рекурсивно.
	\item Объединяем решения подзадач некоторым  образом.
\end{enumerate}
Этот алгоритм даст решение общей задачи.

\

Вернёмся к \emph{сортировке слиянием}. Алгоритм состоит из трёх шагов:
\begin{enumerate}
    \item Раделить массив напополам --- $\Theta(1)$
    \item Рекурсивно решить подзадачи --- $2 T(\frac{n}{2})$
    \item Слияние уже отсортированных массивов --- $\Theta(n)$
\end{enumerate}

\[T(n) = 2T\left(\frac n2\right) + \Theta(n) \implies \Theta(n\log n)\]

Задача та же --- отсортировать массив.

Воспользуемся методом ``Разделяй и властвуй''. Разобьем по-другому:

Выберем в массиве опорный элемент $x$ (как угодно). Выбор важен, от него может много зависить. Пройдем по всем элементам и запишем те элементы, что меньше $x$ до него, а те, что больше --- после.

Две подзадачи: сортировка двух подмассивов.

Третий шаг --- соединить их.

\begin{algorithm}
\caption{Разбитие массива на подмассивы}
\begin{algorithmic}[1]
\Function{partition}{$a, p, q$}\Comment{$a$ --- массив, $p$ и $q$ --- индексы начала и конца соотвественно}
	\State $i \mathrel{:=} p$
	\For{$j \mathrel{:=} p + 1$ to $q$}
		\If{$a[j] < a[p]$}
			\State $i \mathrel{:=} i + 1$
			\State $\textsc{swap}(a[i], a[j])$
		\EndIf
	\EndFor
	\State return $i$
\EndFunction
\end{algorithmic}
\end{algorithm}

Рассмотрим работу алгоритма на примере массива $\{6, 3, 8, 7, 5 ,1\}$:
\begin{enumerate}
	\item $j = 1$. Так как $6 > 3$, то запускается тело цикла. Тогда $i = 1$ и 3 остаётся на месте.
	
	\item $j = 2$. Так как $6 < 8$, то ничего не изменяется.
	
	\item $j = 3$. Так как $6 < 7$, то ничего не изменяется.
	
	\item $j = 4$. Так как $6 > 5$, то запускается тело цикла. Тогда $i = 2$ и числа 5 и 8 меняются местами.
	\[\begin{array}{|c|c|c|c|c|c|}
		\hline 6 & 3 & \textbf{8} & 7 & \textbf{5} & 1 \\
		\hline
	\end{array}
	\longrightarrow
	\begin{array}{|c|c|c|c|c|c|}
	\hline 6 & 3 & \textbf{5} & 7 & \textbf{8} & 1 \\
	\hline
	\end{array}\]
	
	\item $j = 5$. Так как $6 > 1$, то запускается тело цикла. Тогда $i = 3$ и 7 и 1 меняются местами.
	
	\[\begin{array}{|c|c|c|c|c|c|}
	\hline 6 & 3 & 5 & \textbf{7} & 8 & \textbf{1} \\
	\hline
	\end{array}
	\longrightarrow
	\begin{array}{|c|c|c|c|c|c|}
	\hline 6 & 3 & 5 & \textbf{1} & 8 & \textbf{7} \\
	\hline
	\end{array}\]
	
	\item Последний шаг --- переставить опорный элемент на место $i$:
	
	\[\begin{array}{|c|c|c|c|c|c|}
	\hline \textbf{6} & 3 & 5 & \textbf{1} & 8 & 7 \\
	\hline
	\end{array}
	\longrightarrow
	\begin{array}{|c|c|c|c|c|c|}
	\hline \textbf{1} & 3 & 5 & \textbf{6} & 8 & 7 \\
	\hline
	\end{array}\]
\end{enumerate}

\

Теперь рассмотрим скорость работы алгоритма.

\begin{enumerate}
    \item Разбить задачу на подзадачи --- $\Theta(n)$
    \item Рекурсивно решить подзадачи. Пусть индекс опорного элемента равен $r$. Тогда на выполнение уйдёт $T(r-1) + T(n-r)$.
    \item Объединить решения задач в одно глобальное --- $0$ (уже сделано).
\end{enumerate}

Тогда скорость работы алгоритма задаётся следующим рекуррентным соотношением:
\[T(n) = T(r-1) + T(n-r) + \Theta(n)\]

Рассмотрим возможные случаи:

\begin{enumerate}
	\item \textbf{Оптимальный вариант} --- $r$ всегда посередине:
	
	\[T(n) = 2T\left(\frac{n}{2}\right) + \Theta(n) \implies T(n) = \Theta(n\log n)\]
	
	\item \textbf{Худший случай} --- $r$ всегда минимален/максимален (массив уже <<почти>> отсортирован):
	
	\[T(n) = T(n-1) + \Theta(n) \implies T(n) = \Theta(n^2)\]
	
	\item \textbf{Средний случай.} Пусть каждый раз обе части не меньше четверти.
	
	\emph{Подзадачей типа $j$} называется задача такая, что размер входного массива $n'$ соответсвтует следующему неравенству:
	\[n\left(\frac{3}{4}\right)^{j+1} < n' \leqslant n\left(\frac{3}{4}\right)^{j}\]
	
	Не считая рекурсии, на каждую подзадачу типа $j$ уходит $O\left(\left(\frac{3}{4}\right)^{j}n\right)$.
	
	Стоит заметить, что подзадачи типа $j$ не пересекаются по разбиению. При этом из них получаются подзадачи типа не меньше $j+1$.
	
	При этом количество подзадач типа $j$ не больше $\left(\frac{4}{3}\right)^{j+1}$. Отсюда получаем, что на все подзадачи типа $j$ нужно $O\left(\left(\frac{4}{3}\right)^{j+1}\left(\frac{3}{4}\right)^{j}n\right) = O(n)$.
	
	Так как максимальный тип подзадачи можно ограничить сверху $\log_{4/3} n$, то оценка работы в среднем случае равна $O(n \log n)$. При условии, что <<везёт>> всегда.
\end{enumerate}

\subsection*{Как обеспечить везение?}

Мы хотим, чтобы опорный элемент был близок к середине (в отсортированном массиве). Условно, в пределах средних двух четвертей. Если выбирать наугад, вероятность $50\%$.

Предположим, что мы выбираем случайный элемент. Распределим все прочие, и если одна из частей меншь четверти, забудем про этот элемент и выберем другой. Повторим, пока не получим хороший элемент. В среднем на это уйдёт две попытки $\left( \frac1P \right)$. На сложности алгоритма это не сказывается никак, т.к. меняется только константа. Зато теперь так не только в лучшем, но и в среднем случае.
\end{document}
